{"name":"Toobject","tagline":"Handle native php types as objects","body":"# ToObject\r\n\r\nToObject is a library written in PHP. It wraps around a few primitives types and provides a more OOP-like feel by doing so. ToObject uses conventions which derive from several other languages such as C (C zero-terminated strings) and Ruby. In fact, the way in which Ruby Strings(-literals), Arrays and Hashes are used is the main inspiration for creating this library. ToObject thus contains a class for Strings, Arrays (numerical indices) and Hashes (non-numerical indices).\r\n\r\nToObject consists of four primarily classes which together provide all features. It is important to note that all of these classes rely on each other and thus should not be used separately. The four classes are:\r\n\r\n\t- ObjectClass\r\n\t- ArrayClass\r\n\t- HashClass\r\n\t- StringClass\r\n\r\nOf those four, ObjectClass functions as a Base class. It's what java.lang.Object is in Java and what Object (or BasicObject) is in Ruby. However, ObjectClass is not as fancy as the other two :).\r\nThe other three classes are used for arrays, hashes and strings respectively.\r\n\r\n##tl;dr\r\nHow do I get this to work?  \r\nAll you need are the contents of the `src` folder. Include `ToObject.php` and you're good to go. Be sure to use `use` and/or `namespace` though.\r\n\r\n## StringClass\r\nStarting with the most easy one, StringClass. One only has to instantiate a StringClass by passing a string to the constructor. \r\n\r\n\t$str = new StringClass(\"hello, World!\");\r\n\r\nThis will create a new instance with the content \"hello, World!\".  \r\nOne could then call capitalize to make it \"Hello, World!\".\r\n\r\n\t$str->capitalize(); // Hello, World!\r\n\r\nConsult the class documentation to see what methods this class has.\r\n\r\n## Collections\r\nSlightly more advanced are the Array- and Hash- Classes, as they both deal with collections of data. And because they both deal with collections of data, something needs to distinct them from each other. An easy solution is to distinct in what is passed to the constructor and that is exactly how it is done.\r\n\r\nAn ArrayClass needs to be passed an array to its constructor, whereas a HashClass needs to be passed an instance of stdClass. This, at the same time, solves another problem.  \r\nAs mentioned above, both are collections of data. It would be nice for ToObject to recognize the elements inside the collection and determine whether it should be a nested set of ToObject classes.\r\n\r\nLets just jump into an example for clarity. Imagine a database just returned a few records of employees. In native php, fetched and well, it would (or at least could) look like this.\r\n\r\n\tarray(\r\n\t\t0 => stdClass(\r\n\t\t\t[name] => john\r\n\t\t\t[age] => 34\r\n\t\t)\r\n\t\t1 => stdClass(\r\n\t\t\t[name] => sarah\r\n\t\t\t[age] => 40\r\n\t\t)\r\n\t)\r\n\r\n**Note however that these records already are of the stdClass type, this is for the purpose of the example.**\r\n\r\nInstantiating an ArrayClass of this result-set would do a few things.  \r\nFirst, ArrayClass iterates through its collection and determines these elements are stdClasses. Whenever it encounters an stdClass, it will instantiate a HashClass for it.  \r\nThen, HashClass also iterates through its collection and determines it has a string for \"name\". When encountering a string, it will instantiate a StringClass for it. Integers are not dealt with and will therefore remain as is. After all progressing is done, the result-set will look like this.\r\n\r\n\tArrayClass (\r\n\t\t0 => HashClass (\r\n\t\t\t[name] => StringClass: john\r\n\t\t\t[age] => 34\r\n\t\t)\r\n\t\t1 => HashClass (\r\n\t\t\t[name] => StringClass: sarah\r\n\t\t\t[age] => 40\r\n\t\t)\r\n\t)\r\n\r\nAccessing the elements is as if it really just is an array or stdClass:\r\n\r\n\t$person = $arrayclass[0]; // HashClass of john/34\r\n\t$person->name; // StringClass \"john\"\r\n\r\nIn short this can be formulated as: \"Both ArrayClass and HashClass iterate through their elements and try to determine whether any of these elements is to be another instance of ToObject\". This ensures recursive functionality.\r\n\r\nConsult the source-code of \"ObjectClass\" and see the \"builder\" method for information on how this is determined.\r\n\r\n## A Note On HashClass\r\nThough it is called a hash, it actually is not.\r\nA real hash, like a HashTable, computes a key for its data and stores its data in an internal array. HashClass DOES NOT DO THIS. HashClass is merely a key-value storage with no extra internal computations. Internally it uses an stdClass and uses its getters and setters. HashClass basically adds functionalities to the stdClass by applying methods.\r\n\r\n# Communal Methods & Similarities\r\n\r\nToObject allows method chaining - which is also known as the [fluent interface](). Meaning that most methods will return either the current instance or a new instance of the class of which they reside, depending on what the method needs to achieve.\r\n\r\nTaking the last example of the [Collections](## Collections) section. Retrieving the name can also be done in one step rather than to. What was written as:\r\n\r\n\t$person = $arrayclass[0]; // HashClass of john/34\r\n\t$person->name; // StringClass \"john\"\r\n\r\nCan also be written as:\r\n\r\n\t$arrayclass[0]->name; // StringClass \"john\"\r\n\r\nOne more example to get the hang of it.\r\nAs you might have noticed, the names are all lowercase. Of course this should be capitalized. Here it is:\r\n\r\n\t$arrayclass[0]->name->capitalize(); // StringClass \"John\"\r\n\r\nEnough about the fluent interface. There are some methods they have in common, these are:\r\n\r\n* to\\_s():  \r\n\tReturns a string presentation of the object.\r\n* to\\_native([$recursive = true]):  \r\n\tReturns (optionally recursive) a native php type. Meaning an ArrayClass will return an array(), HashClass will return an stdClass and StringClass a string.\r\n* \\_\\_new\\_\\_():  \r\n\tBuilds a new instance of the given type. However, this is not a public method.\r\n\r\nSome classes have a few more of these conversion methods, specifically tied to their own type.\r\n\r\n**ArrayClass**  \r\n\r\n* to\\_hsh():  \r\n\tIf the array is in the format of \"[ [key1, val1], [key2, val2] ]\", to_hsh() will return a HashClass in the form of \":key1 => val1, :key2 => val2\".\r\n\r\n**HashClass**\r\n\r\n* to_a():  \r\n\tReturns an ArrayClass in the form of \"[ [key1, val1], [key2, val2] ]\".\r\n* to\\_native\\_a([$recursive = true]):  \r\n\tReturns a native array in the form of \"[ key1 => val1, key2 => val2 ]\".\r\n\r\nLast but not least, multibyte strings cannot be forgotten. ToObject makes use of the mb\\_*() functions. Assuming they do their job, only UTF-8 is tested, which is also the default encoding for instantiating any object.\r\nFor the methods returning a new instance of the object, the new object will have the same encoding as the old one is instantiated with.\r\nInstantiating an object with a different encoding is easy:\r\n\r\n\t$object = new <any of the classes>($data [ , $encoding = 'UTF-8' ]);\r\n\r\n# Prerequisites\r\n\r\nIn order to use this library, [php5.4.0][] or greater is needed. At the time of writing, [php5.4.6][] is the newest version.\r\n\r\nPHP needs to be compiled with these options:\r\n\r\n    --enable-mbstring\r\n    --with-pcre-regex\r\n    --enable-utf8 *\r\n    --enable-unicode-properties *\r\n    \r\n\\*) These actually are not PHP options, but PCRE options. One would have to (re-)compile PCRE with these flags in order to use [these](http://php.net/manual/en/regexp.reference.unicode.php) goods.\r\n\r\nFurther info on compile options:\r\n\r\n- [mbstring](http://php.net/manual/en/intro.mbstring.php) - mbstring is designed to handle Unicode-based encodings.\r\n- [pcre](http://php.net/manual/en/intro.pcre.php) - perl compatible regular expressions.\r\n\r\nFor the curious ones, this is why ToObject needs PHP5.4.x:\r\n\r\n- [namespaces][] - (5.3.0) Namespaces provide a way in which to group related classes, interfaces, functions and constants.\r\n- [traits][] - (5.4.0) Traits intend to reduce single-inheritance limitations.\r\n- [callable][] - (5.4.0) typehint for callbacks.\r\n- [closures][] - Anonymous functions.\r\n- [array short syntax](http://nl.php.net/manual/en/language.types.array.php) - (5.4.0) short syntax support: array() -> [].\r\n- [\\_\\_DIR\\_\\_]() - (5.3.0) equivalent of dirname(\\_\\_FILE\\_\\_).\r\n \r\n\r\n# Obtaining ToObject\r\n\r\nBy downloading this package you should have:\r\n\r\n- Source code of ToObject\r\n- Source code of the Unit Tests\r\n  \r\n  \r\n# Tests\r\n\r\nThis package is developed on OSX Lion using php5.4.6 and tested with PHPUnit:\r\n\r\n- on a Debian box with:\r\n\r\n    * php5.4.6\r\n    * php5.4.7\r\n- on a OSX ML box with:\r\n    * php5.5.0\r\n\r\n\r\n \r\n[php5.4.0]:     http://php.net/get/php-5.4.0.tar.gz/from/a/mirror\r\n[php5.4.6]:     http://php.net/get/php-5.4.6.tar.gz/from/a/mirror\r\n[php5.4.7]:     http://php.net/get/php-5.4.7.tar.gz/from/a/mirror\r\n[namespaces]:   ttp://php.net/manual/en/language.namespaces.php\r\n[traits]:       http://php.net/manual/en/language.oop5.traits.php\r\n[callable]:     http://php.net/manual/en/language.types.callable.php\r\n[closures]:     http://nl.php.net/manual/en/functions.anonymous.php ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}